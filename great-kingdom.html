<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê·¸ë ˆì´íŠ¸ í‚¹ë¤ (Great Kingdom)</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', 'Malgun Gothic', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1200px;
            width: 100%;
        }

        .game-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .game-header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .game-header .subtitle {
            color: #666;
            font-size: 1.1em;
        }

        .game-content {
            display: flex;
            gap: 30px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .game-board-container {
            flex: 0 0 auto;
        }

        .game-info {
            flex: 0 0 300px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .info-panel {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
        }

        .info-panel h3 {
            margin-bottom: 15px;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .game-board {
            display: inline-grid;
            grid-template-columns: repeat(9, 50px);
            grid-template-rows: repeat(9, 50px);
            gap: 0;
            background: #deb887;
            border: 3px solid #8b4513;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid #a0826d;
            background: #f5deb3;
            cursor: pointer;
            position: relative;
            transition: all 0.2s;
        }

        .cell:hover:not(.occupied) {
            background: #ffeaa7;
            transform: scale(1.05);
        }

        .cell.occupied {
            cursor: not-allowed;
        }

        .cell.center {
            background: #d4a574;
        }

        .stone {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }

        .stone.blue {
            background: linear-gradient(145deg, #4a90e2, #2e5c8a);
            color: white;
        }

        .stone.orange {
            background: linear-gradient(145deg, #ff9500, #cc7700);
            color: white;
        }

        .stone.neutral {
            background: linear-gradient(145deg, #95a5a6, #7f8c8d);
            color: white;
        }

        .current-turn {
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            transition: all 0.3s;
        }

        .current-turn.blue-turn {
            background: #4a90e2;
            color: white;
        }

        .current-turn.orange-turn {
            background: #ff9500;
            color: white;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 10px;
            background: white;
            border-radius: 5px;
        }

        .player-name {
            font-weight: bold;
        }

        .player-name.blue {
            color: #4a90e2;
        }

        .player-name.orange {
            color: #ff9500;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .btn-pass {
            background: #95a5a6;
        }

        .btn-pass:hover {
            background: #7f8c8d;
        }

        .btn-restart {
            background: #e74c3c;
        }

        .btn-restart:hover {
            background: #c0392b;
        }

        .btn-mode {
            background: #667eea;
        }

        .btn-mode:hover {
            background: #5568d3;
        }

        .btn-difficulty {
            font-size: 0.95em;
        }

        .btn-easy {
            background: #2ecc71;
        }

        .btn-easy:hover {
            background: #27ae60;
        }

        .btn-medium {
            background: #f39c12;
        }

        .btn-medium:hover {
            background: #e67e22;
        }

        .btn-hard {
            background: #e74c3c;
        }

        .btn-hard:hover {
            background: #c0392b;
        }

        .btn-difficulty.active {
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }

        .game-log {
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .log-entry {
            padding: 5px;
            border-bottom: 1px solid #dee2e6;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 500px;
        }

        .modal-content h2 {
            font-size: 2em;
            margin-bottom: 20px;
            color: #333;
        }

        .modal-content p {
            font-size: 1.2em;
            margin-bottom: 30px;
            color: #666;
        }

        .winner-icon {
            font-size: 4em;
            margin-bottom: 20px;
            animation: bounce-in 0.8s ease-out;
        }

        /* í™”ë ¤í•œ ìŠ¹ë¦¬ ì„¸ë ˆëª¨ë‹ˆ */
        @keyframes bounce-in {
            0% { transform: scale(0) rotate(-180deg); opacity: 0; }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes confetti-fall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 215, 0, 1), 0 0 60px rgba(255, 215, 0, 0.8); }
        }

        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            overflow: hidden;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: confetti-fall 3s linear;
        }

        .modal-content.victory {
            animation: glow 2s infinite, scale-pulse 0.5s ease-out;
            background: linear-gradient(135deg, #fff 0%, #ffe 100%);
        }

        /* ëŒ€ê¸°ì‹¤ ìŠ¤íƒ€ì¼ */
        .room-selection {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 30px 0;
        }

        .room-card {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-radius: 15px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            border: 3px solid transparent;
            position: relative;
        }

        .room-card:hover {
            transform: translateY(-5px);
            border-color: #667eea;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .room-card.full {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            cursor: not-allowed;
            opacity: 0.7;
        }

        .room-card.waiting {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            animation: pulse 2s infinite;
        }

        .room-card.playing {
            background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
        }

        .room-number {
            font-size: 2em;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }

        .room-status {
            font-size: 0.9em;
            color: #555;
            margin-top: 5px;
        }

        .room-players {
            font-size: 0.85em;
            color: #666;
            margin-top: 8px;
        }

        .modal-content.large {
            max-width: 800px;
            width: 90%;
        }

        .countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .countdown-overlay.active {
            display: flex;
        }

        .countdown-number {
            font-size: 10em;
            color: white;
            font-weight: bold;
            animation: countdown-pulse 1s ease-in-out;
        }

        @keyframes countdown-pulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        .warning-banner {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
            text-align: center;
            animation: pulse 1.5s infinite;
            display: none;
        }

        .warning-banner.active {
            display: block;
        }

        .reconnect-btn {
            background: #00c853;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            transition: all 0.3s;
        }

        .reconnect-btn:hover {
            background: #00a344;
            transform: scale(1.05);
        }

        @keyframes scale-pulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); opacity: 1; }
        }

        .victory-text {
            font-size: 3em;
            background: linear-gradient(45deg, #FFD700, #FFA500, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-size: 200% auto;
            animation: gradient-shift 2s linear infinite;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        @keyframes gradient-shift {
            0% { background-position: 0% center; }
            100% { background-position: 200% center; }
        }

        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            animation: firework-burst 1s ease-out;
        }

        @keyframes firework-burst {
            0% { transform: translate(0, 0); opacity: 1; }
            100% { transform: translate(var(--tx), var(--ty)); opacity: 0; }
        }

        /* ëŒ€ê¸°ë°© ëª¨ë‹¬ */
        .waiting-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .waiting-modal.active {
            display: flex;
        }

        .waiting-content {
            background: white;
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            min-width: 400px;
        }

        .waiting-content h2 {
            font-size: 2.5em;
            margin-bottom: 20px;
            color: #667eea;
        }

        .waiting-spinner {
            width: 80px;
            height: 80px;
            border: 8px solid #f3f3f3;
            border-top: 8px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .waiting-status {
            font-size: 1.2em;
            color: #666;
            margin: 20px 0;
        }

        .waiting-players {
            font-size: 1.1em;
            color: #999;
            margin-top: 10px;
        }

        .btn-cancel-waiting {
            margin-top: 30px;
            background: #e74c3c;
        }

        .btn-cancel-waiting:hover {
            background: #c0392b;
        }

        .matched-animation {
            animation: matched-bounce 0.6s ease-out;
        }

        @keyframes matched-bounce {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .online-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background: #2ecc71;
            border-radius: 50%;
            margin-left: 8px;
            animation: pulse-online 2s infinite;
        }

        @keyframes pulse-online {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* í„´ íƒ€ì´ë¨¸ */
        .turn-timer {
            margin-top: 15px;
            padding: 15px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
            color: white;
            text-align: center;
        }

        .timer-label {
            font-size: 0.9em;
            margin-bottom: 8px;
            opacity: 0.9;
        }

        .timer-display {
            font-size: 2.5em;
            font-weight: bold;
            font-family: 'Courier New', monospace;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .timer-display.warning {
            color: #ffeb3b;
            animation: timer-pulse 0.5s infinite;
        }

        .timer-display.danger {
            color: #ff5252;
            animation: timer-shake 0.2s infinite;
        }

        @keyframes timer-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        @keyframes timer-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .timer-progress {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .timer-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            border-radius: 4px;
            transition: width 1s linear, background-color 0.3s;
        }

        .timer-progress-bar.warning {
            background: linear-gradient(90deg, #FFC107, #FFD54F);
        }

        .timer-progress-bar.danger {
            background: linear-gradient(90deg, #F44336, #E57373);
        }

        .rules-section {
            text-align: left;
            font-size: 0.95em;
            line-height: 1.8;
        }

        .rules-section h4 {
            color: #667eea;
            margin-top: 15px;
            margin-bottom: 10px;
        }

        .rules-section ul {
            margin-left: 20px;
        }

        .rules-section li {
            margin-bottom: 5px;
        }

        .ai-level-selector {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .level-select {
            width: 100%;
            padding: 10px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1em;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }

        .level-select:hover {
            border-color: #5568d3;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .level-select:focus {
            outline: none;
            border-color: #5568d3;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .level-description {
            padding: 10px;
            background: #f0f4ff;
            border-radius: 5px;
            font-size: 0.9em;
            color: #555;
            min-height: 40px;
        }

        .ai-thinking {
            display: none;
            padding: 10px;
            background: #fff3cd;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            color: #856404;
            animation: pulse 1.5s infinite;
        }

        .ai-thinking.active {
            display: block;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @media (max-width: 768px) {
            .game-content {
                flex-direction: column;
            }
            
            .game-board {
                grid-template-columns: repeat(9, 40px);
                grid-template-rows: repeat(9, 40px);
            }
            
            .cell {
                width: 40px;
                height: 40px;
            }
            
            .stone {
                width: 32px;
                height: 32px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <a href="index.html" style="position: absolute; left: 30px; top: 30px; background: rgba(255,255,255,0.2); padding: 10px 20px; border-radius: 10px; color: white; text-decoration: none; font-weight: bold; transition: all 0.3s; backdrop-filter: blur(10px);" onmouseover="this.style.background='rgba(255,255,255,0.3)'" onmouseout="this.style.background='rgba(255,255,255,0.2)'">
                ğŸ  í™ˆìœ¼ë¡œ
            </a>
            <h1>ğŸ° ê·¸ë ˆì´íŠ¸ í‚¹ë¤ ğŸ°</h1>
            <p class="subtitle">ì´ì„¸ëŒ 9ë‹¨ì´ ë§Œë“  ì „ëµ ë³´ë“œê²Œì„</p>
        </div>

        <div class="game-content">
            <div class="game-board-container">
                <div id="gameBoard" class="game-board"></div>
            </div>

            <div class="game-info">
                <div class="info-panel">
                    <div id="currentTurn" class="current-turn blue-turn">
                        íŒŒë€ìƒ‰ ì°¨ë¡€
                    </div>

                    <!-- ì—°ê²° ëŠê¹€ ê²½ê³  -->
                    <div id="connectionWarning" class="warning-banner">
                        <div id="warningMessage">
                            âš ï¸ ì‹œê°„ ì´ˆê³¼! ì»´í“¨í„°ê°€ ëŒ€ì‹  í”Œë ˆì´ ì¤‘ì…ë‹ˆë‹¤.
                        </div>
                        <button class="reconnect-btn" onclick="game.resumeManualPlay()">ì°¸ì—¬í•˜ê¸°</button>
                    </div>

                    <!-- í„´ íƒ€ì´ë¨¸ -->
                    <div id="turnTimer" class="turn-timer" style="display: none;">
                        <div class="timer-label">â±ï¸ ë‚¨ì€ ì‹œê°„</div>
                        <div id="timerDisplay" class="timer-display">10</div>
                        <div class="timer-progress">
                            <div id="timerProgressBar" class="timer-progress-bar" style="width: 100%;"></div>
                        </div>
                    </div>

                    <div class="player-info">
                        <span class="player-name blue">ğŸ”µ íŒŒë€ìƒ‰ (ì„ ê³µ)</span>
                        <span id="blueStones">40ê°œ ë‚¨ìŒ</span>
                    </div>

                    <div class="player-info">
                        <span class="player-name orange">ğŸŸ  ì£¼í™©ìƒ‰ (í›„ê³µ)</span>
                        <span id="orangeStones">40ê°œ ë‚¨ìŒ</span>
                    </div>
                </div>

                <div class="info-panel">
                    <h3>ê²Œì„ ì¡°ì‘</h3>
                    <div class="controls">
                        <button class="btn btn-pass" onclick="game.pass()">
                            â­ï¸ íŒ¨ìŠ¤
                        </button>
                        <button class="btn btn-restart" onclick="game.restart()">
                            ğŸ”„ ìƒˆ ê²Œì„
                        </button>
                    </div>
                </div>

                <div class="info-panel">
                    <h3>ê²Œì„ ëª¨ë“œ</h3>
                    <div class="controls">
                        <button class="btn btn-mode" id="onlineMatchBtn" onclick="game.startOnlineMatch()">
                            ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „
                        </button>
                        <button class="btn btn-mode" onclick="game.setMode('pvp')">
                            ğŸ‘¥ ë¡œì»¬ 2ì¸
                        </button>
                        <button class="btn btn-mode" onclick="game.setMode('ai')">
                            ğŸ¤– ì»´í“¨í„° ëŒ€ì „
                        </button>
                    </div>
                    <div id="onlineStatus" style="display: none; margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 5px; font-size: 0.9em; color: #2e7d32;">
                        <span id="onlineRoomInfo"></span>
                    </div>
                </div>

                <div class="info-panel" id="aiDifficultyPanel" style="display: none;">
                    <h3>ğŸ¤– AI ë‚œì´ë„</h3>
                    <div class="controls">
                        <button class="btn btn-difficulty btn-easy" onclick="game.setDifficulty('easy')">
                            ğŸ˜Š ì‰¬ì›€
                        </button>
                        <button class="btn btn-difficulty btn-medium" onclick="game.setDifficulty('medium')">
                            ğŸ¤” ë³´í†µ
                        </button>
                        <button class="btn btn-difficulty btn-hard" onclick="game.setDifficulty('hard')">
                            ğŸ˜ˆ ì–´ë ¤ì›€
                        </button>
                    </div>
                    <div id="difficultyInfo" style="margin-top: 10px; font-size: 0.9em; color: #666; line-height: 1.6;">
                        ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”
                    </div>
                </div>

                <div class="info-panel" id="aiLevelPanel" style="display: none;">
                    <h3>ğŸ¯ AI ê¸‰ìˆ˜ ì„ íƒ</h3>
                    <div class="ai-level-selector">
                        <select id="aiLevel" class="level-select" onchange="game.setAILevel(this.value)">
                            <option value="9k">9ê¸‰ - ì…ë¬¸ì (ì´ˆë³´)</option>
                            <option value="8k">8ê¸‰ - ì´ˆê¸‰ì</option>
                            <option value="7k">7ê¸‰ - ê¸°ì´ˆ í•™ìŠµ</option>
                            <option value="6k">6ê¸‰ - ê¸°ë³¸ ì „ëµ</option>
                            <option value="5k" selected>5ê¸‰ - ì¤‘ê¸‰ (ê¸°ë³¸)</option>
                            <option value="4k">4ê¸‰ - ëŠ¥ìˆ™í•¨</option>
                            <option value="3k">3ê¸‰ - ê³ ê¸‰ ì „ëµ</option>
                            <option value="2k">2ê¸‰ - ì „ë¬¸ê°€</option>
                            <option value="1k">1ê¸‰ - ìµœìƒê¸‰</option>
                            <option value="1d">ì´ˆë‹¨ - í”„ë¡œ ì…ë¬¸</option>
                            <option value="2d">2ë‹¨ - ê°•ë ¥í•¨</option>
                            <option value="3d">3ë‹¨ - ë§¤ìš° ê°•í•¨</option>
                            <option value="4d">4ë‹¨ - ê³ ìˆ˜</option>
                            <option value="5d">5ë‹¨ - ëª…ì¸</option>
                            <option value="6d">6ë‹¨ - ë‹¬ì¸</option>
                            <option value="7d">7ë‹¨ - ëŒ€ê°€</option>
                            <option value="8d">8ë‹¨ - êµ­ìˆ˜</option>
                            <option value="9d">9ë‹¨ - ìµœê°• (ì´ì„¸ëŒê¸‰)</option>
                        </select>
                        <div class="level-description" id="levelDescription">
                            5ê¸‰: ê¸°ë³¸ì ì¸ ì „ëµì„ ì‚¬ìš©í•©ë‹ˆë‹¤.
                        </div>
                    </div>
                </div>

                <div class="info-panel">
                    <h3>ğŸ“œ ê²Œì„ ê·œì¹™</h3>
                    <div class="rules-section">
                        <ul>
                            <li>ë²ˆê°ˆì•„ê°€ë©° ë§ì„ ë°°ì¹˜í•©ë‹ˆë‹¤</li>
                            <li>ìƒëŒ€ ë§ì„ <strong>ë‘˜ëŸ¬ì‹¸ë©´ ì¡ìŠµë‹ˆë‹¤</strong></li>
                            <li>ìƒëŒ€ ë§ì„ <strong>1ê°œë¼ë„ ì¡ìœ¼ë©´ ì¦‰ì‹œ ìŠ¹ë¦¬!</strong></li>
                            <li>ë‘˜ ë‹¤ íŒ¨ìŠ¤í•˜ë©´ ì˜í†  ê³„ì‚°</li>
                            <li>ì„ ê³µì€ 3ê°œ ë” ë§ì•„ì•¼ ìŠ¹ë¦¬</li>
                        </ul>
                    </div>
                </div>

                <div class="info-panel">
                    <h3>ê²Œì„ ë¡œê·¸</h3>
                    <div id="gameLog" class="game-log">
                        <div class="log-entry">ê²Œì„ ì‹œì‘! íŒŒë€ìƒ‰ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤.</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- ìŠ¹ë¦¬ ëª¨ë‹¬ -->
    <div id="winnerModal" class="modal">
        <div id="modalContent" class="modal-content">
            <div class="winner-icon" id="winnerIcon">ğŸ‰</div>
            <h2 id="winnerText">ìŠ¹ë¦¬!</h2>
            <p id="winnerDetail"></p>
            <div id="modalButtons" style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                <button class="btn btn-restart" onclick="game.closeModal()">í™•ì¸</button>
            </div>
        </div>
    </div>

    <!-- ë°© ì„ íƒ ëª¨ë‹¬ -->
    <div id="roomModal" class="modal">
        <div class="modal-content large">
            <h2>ğŸ® ì˜¨ë¼ì¸ ëŒ€ì „ - ë°© ì„ íƒ</h2>
            <p>ì…ì¥í•  ë°©ì„ ì„ íƒí•˜ì„¸ìš”</p>

            <div id="roomSelection" class="room-selection">
                <!-- 9ê°œ ë°©ì´ ë™ì ìœ¼ë¡œ ìƒì„±ë©ë‹ˆë‹¤ -->
            </div>

            <button class="btn btn-cancel-waiting" onclick="game.closeRoomModal()" style="margin-top: 20px;">
                ë‹«ê¸°
            </button>
        </div>
    </div>

    <!-- ì¹´ìš´íŠ¸ë‹¤ìš´ ì˜¤ë²„ë ˆì´ -->
    <div id="countdownOverlay" class="countdown-overlay">
        <div class="countdown-number" id="countdownNumber">3</div>
    </div>

    <!-- í­ì£½ ì»¨í…Œì´ë„ˆ -->
    <div id="confettiContainer" class="confetti-container"></div>

    <!-- ì˜¨ë¼ì¸ ë°© ì‹œìŠ¤í…œ ìŠ¤í¬ë¦½íŠ¸ -->
    <script src="js/online-room-system.js"></script>

    <script>
        // Supabase ì—°ê²° ì •ë³´
        const SUPABASE_URL = 'https://hoszcmgjmjjximzxdfuk.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhvc3pjbWdqbWpqeGltenhkZnVrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjA2NjIxODcsImV4cCI6MjA3NjIzODE4N30.QUE9wCCbrnRHGKbAapPTC_PPxnbRKmwXuJqh16pyZO0';

        // ê²Œì„ í´ë˜ìŠ¤: ëª¨ë“  ê²Œì„ ë¡œì§ì„ ë‹´ë‹¹í•˜ëŠ” "ë‘ë‡Œ"
        class GreatKingdomGame {
            constructor() {
                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™” (State: ê²Œì„ì˜ í˜„ì¬ ìƒíƒœë¥¼ ì €ì¥)
                this.board = Array(9).fill(null).map(() => Array(9).fill(null));
                this.currentPlayer = 'blue'; // 'blue' ë˜ëŠ” 'orange'
                this.blueStones = 40;
                this.orangeStones = 40;
                this.consecutivePasses = 0;
                this.gameMode = 'pvp'; // 'pvp' ë˜ëŠ” 'ai'
                this.aiDifficulty = 'medium'; // 'easy', 'medium', 'hard'
                this.gameOver = false;
                this.moveHistory = [];

                // ì˜¨ë¼ì¸ ë§¤ì¹­ ì‹œìŠ¤í…œ
                this.onlineMatch = null;
                this.isOnlineMode = false;
                this.myOnlineColor = null;
                this.opponentName = '';

                // í„´ íƒ€ì´ë¨¸ (10ì´ˆ ì œí•œ)
                this.turnTimeLimit = 10; // 10ì´ˆ
                this.currentTurnTime = this.turnTimeLimit;
                this.timerInterval = null;
                this.timerEnabled = false; // ê¸°ë³¸ê°’ì€ ë¹„í™œì„±í™”, ì˜¨ë¼ì¸ ëª¨ë“œì—ì„œë§Œ í™œì„±í™”

                // ì¤‘ë¦½ ì„± ë°°ì¹˜ (ê°€ìš´ë°)
                this.board[4][4] = 'neutral';

                this.init();
            }

            // ê²Œì„ ì´ˆê¸°í™”
            init() {
                this.renderBoard();
                this.updateUI();
                this.addLog('ê²Œì„ ì‹œì‘! íŒŒë€ìƒ‰ë¶€í„° ì‹œì‘í•©ë‹ˆë‹¤.');
            }

            // ë³´ë“œ ë Œë”ë§ (í™”ë©´ì— ê·¸ë¦¬ê¸°)
            renderBoard() {
                const boardElement = document.getElementById('gameBoard');
                boardElement.innerHTML = '';

                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;

                        // ì¤‘ì•™ ì…€ í‘œì‹œ
                        if (row === 4 && col === 4) {
                            cell.classList.add('center');
                        }

                        // ë§ì´ ìˆìœ¼ë©´ í‘œì‹œ
                        const stone = this.board[row][col];
                        if (stone) {
                            cell.classList.add('occupied');
                            const stoneElement = document.createElement('div');
                            stoneElement.className = `stone ${stone}`;
                            if (stone === 'neutral') {
                                stoneElement.textContent = 'â­';
                            }
                            cell.appendChild(stoneElement);
                        }

                        // í´ë¦­ ì´ë²¤íŠ¸
                        cell.addEventListener('click', () => this.handleCellClick(row, col));
                        
                        boardElement.appendChild(cell);
                    }
                }
            }

            // ì…€ í´ë¦­ ì²˜ë¦¬
            handleCellClick(row, col) {
                if (this.gameOver) {
                    alert('ê²Œì„ì´ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ìƒˆ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”.');
                    return;
                }

                // ì˜¨ë¼ì¸ ëª¨ë“œ: ë‚´ ì°¨ë¡€ê°€ ì•„ë‹ˆë©´ í´ë¦­ ë¶ˆê°€
                if (this.isOnlineMode && this.currentPlayer !== this.myOnlineColor) {
                    alert('ìƒëŒ€ë°©ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤.');
                    return;
                }

                // AI ëª¨ë“œì—ì„œ AI ì°¨ë¡€ì¼ ë•ŒëŠ” í´ë¦­ ë¶ˆê°€
                if (this.gameMode === 'ai' && this.currentPlayer === 'orange') {
                    return;
                }

                // ì´ë¯¸ ë§ì´ ìˆëŠ” ê³³ì€ í´ë¦­ ë¶ˆê°€
                if (this.board[row][col] !== null) {
                    alert('ì´ë¯¸ ë§ì´ ìˆëŠ” ìœ„ì¹˜ì…ë‹ˆë‹¤.');
                    return;
                }

                // ìƒëŒ€ë°© ì˜í† ì¸ì§€ í™•ì¸
                if (this.isInOpponentTerritory(row, col)) {
                    alert('ìƒëŒ€ë°© ì˜í† ì—ëŠ” ë§ì„ ë†“ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }

                // ë§ ë°°ì¹˜
                this.placeStone(row, col, true); // ì„¸ ë²ˆì§¸ íŒŒë¼ë¯¸í„°: ì˜¨ë¼ì¸ ì „ì†¡ ì—¬ë¶€
            }

            // ë§ ë°°ì¹˜
            async placeStone(row, col, sendOnline = false) {
                this.board[row][col] = this.currentPlayer;
                this.consecutivePasses = 0;

                // ë‚¨ì€ ë§ ìˆ˜ ê°ì†Œ
                if (this.currentPlayer === 'blue') {
                    this.blueStones--;
                } else {
                    this.orangeStones--;
                }

                this.addLog(`${this.currentPlayer === 'blue' ? 'ğŸ”µ íŒŒë€ìƒ‰' : 'ğŸŸ  ì£¼í™©ìƒ‰'}ì´ (${row + 1}, ${col + 1})ì— ë§ì„ ë†“ì•˜ìŠµë‹ˆë‹¤.`);

                // ì˜¨ë¼ì¸ ëª¨ë“œ: ì´ë™ ì „ì†¡
                if (this.isOnlineMode && sendOnline && this.roomSystem) {
                    try {
                        await this.roomSystem.sendMove('place', row, col, {
                            board: this.board,
                            blueStones: this.blueStones,
                            orangeStones: this.orangeStones
                        });
                    } catch (error) {
                        console.error('ì˜¨ë¼ì¸ ì´ë™ ì „ì†¡ ì‹¤íŒ¨:', error);
                    }
                }

                // ìƒëŒ€ ë§ì„ ì¡ì•˜ëŠ”ì§€ í™•ì¸
                const capturedStones = this.checkCapture(row, col);
                if (capturedStones.length > 0) {
                    this.handleCapture(capturedStones);
                    return;
                }

                // ë‹¤ìŒ í„´
                this.switchPlayer();
                this.renderBoard();
                this.updateUI();

                // AI ëª¨ë“œì—ì„œ AI ì°¨ë¡€ë©´ AI ì‹¤í–‰
                if (this.gameMode === 'ai' && this.currentPlayer === 'orange' && !this.gameOver) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }

            // ìƒëŒ€ë°© ì˜í† ì¸ì§€ í™•ì¸
            isInOpponentTerritory(row, col) {
                const opponent = this.currentPlayer === 'blue' ? 'orange' : 'blue';
                // ê°„ë‹¨í•œ êµ¬í˜„: ì£¼ë³€ì´ ëª¨ë‘ ìƒëŒ€ ë§ì´ê±°ë‚˜ ê°€ì¥ìë¦¬ë©´ ì˜í† ë¡œ ê°„ì£¼
                // ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ì•Œê³ ë¦¬ì¦˜ í•„ìš”
                return false; // ì¼ë‹¨ ê°„ë‹¨í•˜ê²Œ êµ¬í˜„
            }

            // í¬íš í™•ì¸ (ìƒëŒ€ ë§ì„ ë‘˜ëŸ¬ìŒŒëŠ”ì§€)
            checkCapture(row, col) {
                const opponent = this.currentPlayer === 'blue' ? 'orange' : 'blue';
                const captured = [];

                // ìƒí•˜ì¢Œìš° í™•ì¸
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                
                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;
                    
                    if (this.isValidCell(newRow, newCol) && this.board[newRow][newCol] === opponent) {
                        // ì´ ìƒëŒ€ ë§ì´ ë‘˜ëŸ¬ì‹¸ì˜€ëŠ”ì§€ í™•ì¸
                        if (this.isSurrounded(newRow, newCol, opponent)) {
                            captured.push([newRow, newCol]);
                        }
                    }
                }

                return captured;
            }

            // ë§ì´ ë‘˜ëŸ¬ì‹¸ì˜€ëŠ”ì§€ í™•ì¸ (BFS ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©)
            isSurrounded(row, col, color) {
                const visited = Array(9).fill(null).map(() => Array(9).fill(false));
                const queue = [[row, col]];
                visited[row][col] = true;
                const group = [[row, col]];

                // BFSë¡œ ì—°ê²°ëœ ê°™ì€ ìƒ‰ ê·¸ë£¹ ì°¾ê¸°
                while (queue.length > 0) {
                    const [r, c] = queue.shift();
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

                    for (const [dr, dc] of directions) {
                        const newRow = r + dr;
                        const newCol = c + dc;

                        if (!this.isValidCell(newRow, newCol)) continue;
                        if (visited[newRow][newCol]) continue;

                        visited[newRow][newCol] = true;

                        // ë¹ˆ ì¹¸ì´ ìˆìœ¼ë©´ ë‘˜ëŸ¬ì‹¸ì´ì§€ ì•ŠìŒ
                        if (this.board[newRow][newCol] === null || this.board[newRow][newCol] === 'neutral') {
                            return false;
                        }

                        // ê°™ì€ ìƒ‰ì´ë©´ ê·¸ë£¹ì— ì¶”ê°€
                        if (this.board[newRow][newCol] === color) {
                            queue.push([newRow, newCol]);
                            group.push([newRow, newCol]);
                        }
                    }
                }

                return true;
            }

            // ìœ íš¨í•œ ì…€ì¸ì§€ í™•ì¸
            isValidCell(row, col) {
                return row >= 0 && row < 9 && col >= 0 && col < 9;
            }

            // í¬íš ì²˜ë¦¬
            handleCapture(capturedStones) {
                this.addLog(`ğŸ¯ ${this.currentPlayer === 'blue' ? 'ğŸ”µ íŒŒë€ìƒ‰' : 'ğŸŸ  ì£¼í™©ìƒ‰'}ì´ ìƒëŒ€ ë§ ${capturedStones.length}ê°œë¥¼ ì¡ì•˜ìŠµë‹ˆë‹¤!`);
                
                // ë§ ì œê±°
                for (const [row, col] of capturedStones) {
                    this.board[row][col] = null;
                }

                // ìƒëŒ€ ë§ì„ í•˜ë‚˜ë¼ë„ ì¡ìœ¼ë©´ ì¦‰ì‹œ ìŠ¹ë¦¬!
                this.endGame(`${this.currentPlayer === 'blue' ? 'ğŸ”µ íŒŒë€ìƒ‰' : 'ğŸŸ  ì£¼í™©ìƒ‰'} ìŠ¹ë¦¬!`, 
                            `ìƒëŒ€ ë§ì„ ${capturedStones.length}ê°œ ì¡ì•„ì„œ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`);
            }

            // íŒ¨ìŠ¤
            pass() {
                if (this.gameOver) return;

                this.consecutivePasses++;
                this.addLog(`${this.currentPlayer === 'blue' ? 'ğŸ”µ íŒŒë€ìƒ‰' : 'ğŸŸ  ì£¼í™©ìƒ‰'}ì´ íŒ¨ìŠ¤í–ˆìŠµë‹ˆë‹¤.`);

                // ì—°ì† 2ë²ˆ íŒ¨ìŠ¤í•˜ë©´ ê²Œì„ ì¢…ë£Œ
                if (this.consecutivePasses >= 2) {
                    this.calculateTerritory();
                    return;
                }

                this.switchPlayer();
                this.updateUI();

                // AI ëª¨ë“œì—ì„œ AI ì°¨ë¡€ë©´ AI ì‹¤í–‰
                if (this.gameMode === 'ai' && this.currentPlayer === 'orange' && !this.gameOver) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }

            // ì˜í†  ê³„ì‚°
            calculateTerritory() {
                let blueTerritory = 0;
                let orangeTerritory = 0;

                // ê°„ë‹¨í•œ ì˜í†  ê³„ì‚°: ê° í”Œë ˆì´ì–´ì˜ ë§ ê°œìˆ˜ì™€ ë¹ˆ ì¹¸ ì£¼ë³€ í™•ì¸
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === 'blue') {
                            blueTerritory++;
                        } else if (this.board[row][col] === 'orange') {
                            orangeTerritory++;
                        } else if (this.board[row][col] === null) {
                            // ë¹ˆ ì¹¸ì˜ ì˜í†  íŒì • (ì£¼ë³€ ë§ í™•ì¸)
                            const owner = this.getTerritoryOwner(row, col);
                            if (owner === 'blue') blueTerritory++;
                            else if (owner === 'orange') orangeTerritory++;
                        }
                    }
                }

                // ìŠ¹ì ê²°ì • (ì„ ê³µì€ 3ê°œ ë” ë§ì•„ì•¼ ìŠ¹ë¦¬)
                const diff = blueTerritory - orangeTerritory;
                let winner, detail;
                
                if (diff >= 3) {
                    winner = 'ğŸ”µ íŒŒë€ìƒ‰ ìŠ¹ë¦¬!';
                    detail = `ì˜í† : íŒŒë€ìƒ‰ ${blueTerritory} vs ì£¼í™©ìƒ‰ ${orangeTerritory} (ì°¨ì´: +${diff})`;
                } else {
                    winner = 'ğŸŸ  ì£¼í™©ìƒ‰ ìŠ¹ë¦¬!';
                    detail = `ì˜í† : íŒŒë€ìƒ‰ ${blueTerritory} vs ì£¼í™©ìƒ‰ ${orangeTerritory} (ì„ ê³µ ë¶ˆë¦¬ ë³´ì •)`;
                }

                this.endGame(winner, detail);
            }

            // ë¹ˆ ì¹¸ì˜ ì˜í†  ì†Œìœ ì íŒì •
            getTerritoryOwner(row, col) {
                const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                let blueCount = 0;
                let orangeCount = 0;

                for (const [dr, dc] of directions) {
                    const newRow = row + dr;
                    const newCol = col + dc;

                    if (this.isValidCell(newRow, newCol)) {
                        if (this.board[newRow][newCol] === 'blue') blueCount++;
                        else if (this.board[newRow][newCol] === 'orange') orangeCount++;
                    } else {
                        // ê°€ì¥ìë¦¬ë„ ê³ ë ¤
                    }
                }

                if (blueCount > orangeCount) return 'blue';
                if (orangeCount > blueCount) return 'orange';
                return null;
            }

            // í”Œë ˆì´ì–´ ì „í™˜
            switchPlayer() {
                this.currentPlayer = this.currentPlayer === 'blue' ? 'orange' : 'blue';

                // íƒ€ì´ë¨¸ ì¬ì‹œì‘
                if (this.timerEnabled && !this.gameOver) {
                    this.startTimer();
                }
            }

            // AI ì´ë™
            aiMove() {
                // AI ì‚¬ê³  ì¤‘ í‘œì‹œ
                const validMoves = this.getValidMoves();
                
                if (validMoves.length === 0) {
                    this.pass();
                    return;
                }

                let selectedMove;
                
                // ê¸‰ìˆ˜ì— ë”°ë¼ ë‹¤ë¥¸ ì „ëµ ì‚¬ìš©
                switch(this.aiLevel) {
                    case '9k': // ì™„ì „ ëœë¤
                        selectedMove = this.aiLevel9k(validMoves);
                        break;
                    case '8k': // ì¤‘ì•™ ì„ í˜¸
                        selectedMove = this.aiLevel8k(validMoves);
                        break;
                    case '7k': // ê¸°ë³¸ ë°©ì–´
                        selectedMove = this.aiLevel7k(validMoves);
                        break;
                    case '6k': // ê³µê²©+ë°©ì–´
                        selectedMove = this.aiLevel6k(validMoves);
                        break;
                    case '5k': // ì˜í†  í™•ì¥
                        selectedMove = this.aiLevel5k(validMoves);
                        break;
                    case '4k': // í¬ìœ„ ì „ëµ
                        selectedMove = this.aiLevel4k(validMoves);
                        break;
                    case '3k': // 2ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelKyu(validMoves, 2);
                        break;
                    case '2k': // 3ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelKyu(validMoves, 3);
                        break;
                    case '1k': // 4ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelKyu(validMoves, 4);
                        break;
                    case '1d': // 5ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelDan(validMoves, 5);
                        break;
                    case '2d': // 6ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelDan(validMoves, 6);
                        break;
                    case '3d': // 7ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelDan(validMoves, 7);
                        break;
                    case '4d': // 8ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelDan(validMoves, 8);
                        break;
                    case '5d': // 9ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelDan(validMoves, 9);
                        break;
                    case '6d': // 10ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelDan(validMoves, 10);
                        break;
                    case '7d': // 11ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelDan(validMoves, 11);
                        break;
                    case '8d': // 12ìˆ˜ ì½ê¸°
                        selectedMove = this.aiLevelDan(validMoves, 12);
                        break;
                    case '9d': // ìµœê°• (14ìˆ˜ ì½ê¸°)
                        selectedMove = this.aiLevelDan(validMoves, 14);
                        break;
                    default:
                        selectedMove = this.aiLevel5k(validMoves);
                }
                
                if (selectedMove) {
                    this.placeStone(selectedMove[0], selectedMove[1]);
                } else {
                    this.pass();
                }
            }

            // ìœ íš¨í•œ ìˆ˜ ê°€ì ¸ì˜¤ê¸°
            getValidMoves() {
                const moves = [];
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === null && !this.isInOpponentTerritory(row, col)) {
                            moves.push([row, col]);
                        }
                    }
                }
                return moves;
            }

            // 9ê¸‰ AI: ì™„ì „ ëœë¤
            aiLevel9k(validMoves) {
                return validMoves[Math.floor(Math.random() * validMoves.length)];
            }

            // 8ê¸‰ AI: ì¤‘ì•™ ì„ í˜¸
            aiLevel8k(validMoves) {
                validMoves.sort((a, b) => {
                    const distA = Math.abs(a[0] - 4) + Math.abs(a[1] - 4);
                    const distB = Math.abs(b[0] - 4) + Math.abs(b[1] - 4);
                    return distA - distB;
                });
                
                const topMoves = validMoves.slice(0, Math.max(1, Math.floor(validMoves.length * 0.4)));
                return topMoves[Math.floor(Math.random() * topMoves.length)];
            }

            // 7ê¸‰ AI: ê¸°ë³¸ ë°©ì–´
            aiLevel7k(validMoves) {
                // ë‚´ ë§ ê·¼ì²˜ì— ë‘ê¸°
                const myStones = [];
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === 'orange') {
                            myStones.push([row, col]);
                        }
                    }
                }

                if (myStones.length > 0) {
                    validMoves.sort((a, b) => {
                        const minDistA = Math.min(...myStones.map(s => 
                            Math.abs(a[0] - s[0]) + Math.abs(a[1] - s[1])
                        ));
                        const minDistB = Math.min(...myStones.map(s => 
                            Math.abs(b[0] - s[0]) + Math.abs(b[1] - s[1])
                        ));
                        return minDistA - minDistB;
                    });
                }

                const topMoves = validMoves.slice(0, Math.max(1, Math.floor(validMoves.length * 0.3)));
                return topMoves[Math.floor(Math.random() * topMoves.length)];
            }

            // 6ê¸‰ AI: ê³µê²©+ë°©ì–´
            aiLevel6k(validMoves) {
                // ìƒëŒ€ ë§ ê·¼ì²˜ ë˜ëŠ” ë‚´ ë§ ê·¼ì²˜
                const scored = validMoves.map(move => {
                    let score = 0;
                    const [row, col] = move;
                    
                    // ì£¼ë³€ í™•ì¸
                    const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                    for (const [dr, dc] of directions) {
                        const nr = row + dr;
                        const nc = col + dc;
                        if (this.isValidCell(nr, nc)) {
                            if (this.board[nr][nc] === 'blue') score += 2; // ìƒëŒ€ ê·¼ì²˜
                            if (this.board[nr][nc] === 'orange') score += 1; // ë‚´ ë§ ê·¼ì²˜
                        }
                    }
                    
                    // ì¤‘ì•™ ì„ í˜¸
                    const centerDist = Math.abs(row - 4) + Math.abs(col - 4);
                    score += (8 - centerDist) * 0.5;
                    
                    return { move, score };
                });

                scored.sort((a, b) => b.score - a.score);
                const topMoves = scored.slice(0, Math.max(1, Math.floor(scored.length * 0.25)));
                const selected = topMoves[Math.floor(Math.random() * topMoves.length)];
                return selected.move;
            }

            // 5ê¸‰ AI: ì˜í†  í™•ì¥
            aiLevel5k(validMoves) {
                const scored = validMoves.map(move => {
                    let score = 0;
                    const [row, col] = move;
                    
                    // ì˜í†  í™•ì¥ ê°€ëŠ¥ì„± í‰ê°€
                    const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                    let emptyNeighbors = 0;
                    let myNeighbors = 0;
                    let enemyNeighbors = 0;
                    
                    for (const [dr, dc] of directions) {
                        const nr = row + dr;
                        const nc = col + dc;
                        if (this.isValidCell(nr, nc)) {
                            if (this.board[nr][nc] === null) emptyNeighbors++;
                            else if (this.board[nr][nc] === 'orange') myNeighbors++;
                            else if (this.board[nr][nc] === 'blue') enemyNeighbors++;
                        }
                    }
                    
                    score += emptyNeighbors * 2; // ë¹ˆ ê³µê°„ ì„ í˜¸
                    score += myNeighbors * 1.5; // ë‚´ ë§ ì—°ê²°
                    score += enemyNeighbors * 2.5; // ìƒëŒ€ ê²¬ì œ
                    
                    // ì¤‘ì•™ ì„ í˜¸
                    const centerDist = Math.abs(row - 4) + Math.abs(col - 4);
                    score += (8 - centerDist) * 0.8;
                    
                    return { move, score };
                });

                scored.sort((a, b) => b.score - a.score);
                const topMoves = scored.slice(0, Math.max(1, Math.floor(scored.length * 0.2)));
                const selected = topMoves[Math.floor(Math.random() * topMoves.length)];
                return selected.move;
            }

            // 4ê¸‰ AI: í¬ìœ„ ì „ëµ
            aiLevel4k(validMoves) {
                // ìƒëŒ€ë¥¼ í¬ìœ„í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
                for (const move of validMoves) {
                    const [row, col] = move;
                    // ì‹œë®¬ë ˆì´ì…˜: ì´ ìˆ˜ë¥¼ ë‘ë©´ ìƒëŒ€ë¥¼ ì¡ì„ ìˆ˜ ìˆëŠ”ê°€?
                    this.board[row][col] = 'orange';
                    const captured = this.checkCapture(row, col);
                    this.board[row][col] = null;
                    
                    if (captured.length > 0) {
                        return move; // ì¦‰ì‹œ ì¡ì„ ìˆ˜ ìˆìœ¼ë©´ ê·¸ ìˆ˜ë¥¼ ë‘”ë‹¤
                    }
                }
                
                // ì¡ì„ ìˆ˜ ì—†ìœ¼ë©´ 5ê¸‰ ì „ëµ ì‚¬ìš©
                return this.aiLevel5k(validMoves);
            }

            // ê¸‰ AI: ë¯¸ë‹ˆë§¥ìŠ¤ (ê°„ì†Œí™”)
            aiLevelKyu(validMoves, depth) {
                const scored = validMoves.map(move => {
                    const score = this.evaluateMove(move, depth, 'orange');
                    return { move, score };
                });

                scored.sort((a, b) => b.score - a.score);
                const topMoves = scored.slice(0, Math.max(1, Math.floor(scored.length * 0.15)));
                const selected = topMoves[Math.floor(Math.random() * topMoves.length)];
                return selected.move;
            }

            // ë‹¨ AI: ê°•í™”ëœ ë¯¸ë‹ˆë§¥ìŠ¤
            aiLevelDan(validMoves, depth) {
                const scored = validMoves.map(move => {
                    const score = this.evaluateMoveDan(move, depth, 'orange');
                    return { move, score };
                });

                scored.sort((a, b) => b.score - a.score);
                
                // ë†’ì€ ë‹¨ìˆ˜ì¼ìˆ˜ë¡ ìµœì„ ì˜ ìˆ˜ë§Œ ì„ íƒ
                const selectRatio = Math.max(0.05, 0.2 - (depth - 5) * 0.02);
                const topMoves = scored.slice(0, Math.max(1, Math.floor(scored.length * selectRatio)));
                const selected = topMoves[Math.floor(Math.random() * topMoves.length)];
                return selected.move;
            }

            // ìˆ˜ í‰ê°€ (ê¸‰ ìˆ˜ì¤€)
            evaluateMove(move, depth, player) {
                if (depth === 0) {
                    return this.evaluatePosition(player);
                }

                const [row, col] = move;
                this.board[row][col] = player;
                
                // ì¦‰ì‹œ ìŠ¹ë¦¬ í™•ì¸
                const captured = this.checkCapture(row, col);
                if (captured.length > 0) {
                    this.board[row][col] = null;
                    return 10000; // ë§¤ìš° ë†’ì€ ì ìˆ˜
                }

                const score = this.evaluatePosition(player);
                this.board[row][col] = null;
                
                return score;
            }

            // ìˆ˜ í‰ê°€ (ë‹¨ ìˆ˜ì¤€)
            evaluateMoveDan(move, depth, player) {
                if (depth === 0) {
                    return this.evaluatePositionAdvanced(player);
                }

                const [row, col] = move;
                this.board[row][col] = player;
                
                // ì¦‰ì‹œ ìŠ¹ë¦¬ í™•ì¸
                const captured = this.checkCapture(row, col);
                if (captured.length > 0) {
                    this.board[row][col] = null;
                    return 100000; // ë§¤ìš° ë†’ì€ ì ìˆ˜
                }

                let score = this.evaluatePositionAdvanced(player);
                
                // ìƒëŒ€ì˜ ìµœì„  ì‘ìˆ˜ ê³ ë ¤ (ê°„ì†Œí™”ëœ ë¯¸ë‹ˆë§¥ìŠ¤)
                const opponent = player === 'orange' ? 'blue' : 'orange';
                const opponentMoves = this.getValidMoves();
                
                if (opponentMoves.length > 0 && depth > 1) {
                    const opponentScores = opponentMoves.slice(0, Math.min(5, opponentMoves.length)).map(oppMove => {
                        return this.evaluateMoveDan(oppMove, depth - 1, opponent);
                    });
                    const bestOpponentScore = Math.max(...opponentScores);
                    score -= bestOpponentScore * 0.5; // ìƒëŒ€ì˜ ì¢‹ì€ ìˆ˜ëŠ” ê°ì 
                }

                this.board[row][col] = null;
                return score;
            }

            // í¬ì§€ì…˜ í‰ê°€ (ê¸°ë³¸)
            evaluatePosition(player) {
                let score = 0;
                const opponent = player === 'orange' ? 'blue' : 'orange';
                
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === player) {
                            score += 10;
                            
                            // ì—°ê²°ì„± í‰ê°€
                            const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                            for (const [dr, dc] of directions) {
                                const nr = row + dr;
                                const nc = col + dc;
                                if (this.isValidCell(nr, nc)) {
                                    if (this.board[nr][nc] === player) score += 5;
                                    if (this.board[nr][nc] === null) score += 2;
                                }
                            }
                            
                            // ì¤‘ì•™ ìœ„ì¹˜ ê°€ì‚°ì 
                            const centerDist = Math.abs(row - 4) + Math.abs(col - 4);
                            score += (8 - centerDist);
                        } else if (this.board[row][col] === opponent) {
                            score -= 10;
                        }
                    }
                }
                
                return score;
            }

            // í¬ì§€ì…˜ í‰ê°€ (ê³ ê¸‰)
            evaluatePositionAdvanced(player) {
                let score = this.evaluatePosition(player);
                const opponent = player === 'orange' ? 'blue' : 'orange';
                
                // ì˜í–¥ë ¥ í‰ê°€
                for (let row = 0; row < 9; row++) {
                    for (let col = 0; col < 9; col++) {
                        if (this.board[row][col] === null) {
                            let playerInfluence = 0;
                            let opponentInfluence = 0;
                            
                            // ì£¼ë³€ 2ì¹¸ê¹Œì§€ ì˜í–¥ë ¥ ê³„ì‚°
                            for (let dr = -2; dr <= 2; dr++) {
                                for (let dc = -2; dc <= 2; dc++) {
                                    const nr = row + dr;
                                    const nc = col + dc;
                                    if (this.isValidCell(nr, nc)) {
                                        const dist = Math.abs(dr) + Math.abs(dc);
                                        const influence = 3 - dist;
                                        
                                        if (this.board[nr][nc] === player) {
                                            playerInfluence += influence;
                                        } else if (this.board[nr][nc] === opponent) {
                                            opponentInfluence += influence;
                                        }
                                    }
                                }
                            }
                            
                            if (playerInfluence > opponentInfluence) {
                                score += (playerInfluence - opponentInfluence);
                            }
                        }
                    }
                }
                
                return score;
            }

            // ê²Œì„ ëª¨ë“œ ì„¤ì •
            setMode(mode) {
                this.gameMode = mode;
                const aiPanel = document.getElementById('aiLevelPanel');
                
                if (mode === 'ai') {
                    aiPanel.style.display = 'block';
                    this.addLog(`ğŸ¤– ì»´í“¨í„° ëŒ€ì „ ëª¨ë“œ (${this.getAILevelName()})`);
                } else {
                    aiPanel.style.display = 'none';
                    this.addLog('ğŸ‘¥ ëŒ€ì¸ ê²½ê¸° ëª¨ë“œ');
                }
                
                this.restart();
            }

            // AI ë ˆë²¨ ì„¤ì •
            setAILevel(level) {
                this.aiLevel = level;
                const description = this.getAILevelDescription(level);
                document.getElementById('levelDescription').textContent = description;
                this.addLog(`AI ê¸‰ìˆ˜ ë³€ê²½: ${this.getAILevelName()}`);
                
                if (this.gameMode === 'ai' && !this.gameOver) {
                    this.restart();
                }
            }

            // AI ë ˆë²¨ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
            getAILevelName() {
                const levels = {
                    '9k': '9ê¸‰ (ì…ë¬¸ì)',
                    '8k': '8ê¸‰ (ì´ˆê¸‰ì)',
                    '7k': '7ê¸‰ (ê¸°ì´ˆ)',
                    '6k': '6ê¸‰ (ê¸°ë³¸)',
                    '5k': '5ê¸‰ (ì¤‘ê¸‰)',
                    '4k': '4ê¸‰ (ëŠ¥ìˆ™)',
                    '3k': '3ê¸‰ (ê³ ê¸‰)',
                    '2k': '2ê¸‰ (ì „ë¬¸ê°€)',
                    '1k': '1ê¸‰ (ìµœìƒê¸‰)',
                    '1d': 'ì´ˆë‹¨',
                    '2d': '2ë‹¨',
                    '3d': '3ë‹¨',
                    '4d': '4ë‹¨',
                    '5d': '5ë‹¨',
                    '6d': '6ë‹¨',
                    '7d': '7ë‹¨',
                    '8d': '8ë‹¨',
                    '9d': '9ë‹¨ (ìµœê°•)'
                };
                return levels[this.aiLevel] || '5ê¸‰';
            }

            // AI ë ˆë²¨ ì„¤ëª…
            getAILevelDescription(level) {
                const descriptions = {
                    '9k': '9ê¸‰: ì™„ì „ ëœë¤ìœ¼ë¡œ ë‘¡ë‹ˆë‹¤. ì´ˆë³´ìë„ ì‰½ê²Œ ì´ê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.',
                    '8k': '8ê¸‰: ì¤‘ì•™ì„ ì„ í˜¸í•˜ì§€ë§Œ ì „ëµì´ ì—†ìŠµë‹ˆë‹¤.',
                    '7k': '7ê¸‰: ê¸°ë³¸ì ì¸ ë°©ì–´ë§Œ í•©ë‹ˆë‹¤.',
                    '6k': '6ê¸‰: ê³µê²©ê³¼ ë°©ì–´ë¥¼ ì¡°ê¸ˆ ìƒê°í•©ë‹ˆë‹¤.',
                    '5k': '5ê¸‰: ì˜í†  í™•ì¥ì„ ì‹œë„í•©ë‹ˆë‹¤. (ê¸°ë³¸)',
                    '4k': '4ê¸‰: ìƒëŒ€ ë§ í¬ìœ„ë¥¼ ë…¸ë¦½ë‹ˆë‹¤.',
                    '3k': '3ê¸‰: 2ìˆ˜ ì•ì„ ë‚´ë‹¤ë´…ë‹ˆë‹¤.',
                    '2k': '2ê¸‰: 3ìˆ˜ ì•ì„ ë‚´ë‹¤ë³´ë©° ì „ëµì ì…ë‹ˆë‹¤.',
                    '1k': '1ê¸‰: 4ìˆ˜ ì•ì„ ë‚´ë‹¤ë³´ëŠ” ê³ ìˆ˜ì…ë‹ˆë‹¤.',
                    '1d': 'ì´ˆë‹¨: ê°•ë ¥í•œ ì „ëµê³¼ 5ìˆ˜ ì½ê¸°',
                    '2d': '2ë‹¨: ë§¤ìš° ê°•í•œ ìˆ˜ì½ê¸° ëŠ¥ë ¥',
                    '3d': '3ë‹¨: ê±°ì˜ ì™„ë²½í•œ ë°©ì–´',
                    '4d': '4ë‹¨: ê³µê²©ê³¼ ë°©ì–´ì˜ ê· í˜•',
                    '5d': '5ë‹¨: ë³µì¡í•œ í˜•ì„¸ íŒë‹¨',
                    '6d': '6ë‹¨: ê³ ë„ì˜ ì „ëµ ìˆ˜ë¦½',
                    '7d': '7ë‹¨: í”„ë¡œ ìˆ˜ì¤€ì˜ ì‹¤ë ¥',
                    '8d': '8ë‹¨: ê±°ì˜ ì™„ë²½í•œ ìˆ˜ì¤€',
                    '9d': '9ë‹¨: ìµœê°•ì˜ AI. ì´ê¸°ê¸° ë§¤ìš° ì–´ë µìŠµë‹ˆë‹¤!'
                };
                return descriptions[level] || descriptions['5k'];
            }

            // ê²Œì„ ì¢…ë£Œ
            async endGame(winner, detail) {
                this.gameOver = true;
                this.addLog(`ğŸ† ê²Œì„ ì¢…ë£Œ! ${winner}`);

                // íƒ€ì´ë¨¸ ì •ì§€
                this.stopTimer();

                // ì˜¨ë¼ì¸ ëª¨ë“œ: ê²Œì„ ì¢…ë£Œ ì „ì†¡
                if (this.isOnlineMode && this.roomSystem) {
                    await this.roomSystem.endGame(winner);
                }

                // í™”ë ¤í•œ ìŠ¹ë¦¬ ì„¸ë ˆëª¨ë‹ˆ
                this.showVictoryCeremony(winner, detail);

                document.getElementById('winnerText').innerHTML = `<span class="victory-text">${winner}</span>`;
                document.getElementById('winnerDetail').textContent = detail;

                // ì˜¨ë¼ì¸ ëª¨ë“œì—ì„œ ë²„íŠ¼ ë³€ê²½
                const modalButtons = document.getElementById('modalButtons');
                if (this.isOnlineMode && this.roomSystem) {
                    // ìŠ¹ìì¸ì§€ íŒ¨ìì¸ì§€ í™•ì¸
                    const isWinner = winner.includes(this.myOnlineColor === 'blue' ? 'íŒŒë€ìƒ‰' : 'ì£¼í™©ìƒ‰');

                    if (isWinner) {
                        // ì´ê¸´ ì‚¬ëŒ: "ìƒˆë¡œìš´ ê²Œì„ ìš”ì²­ì´ ì™”ìŠµë‹ˆë‹¤. ìˆ˜ë½/ë‚˜ê°€ê¸°"
                        modalButtons.innerHTML = `
                            <p style="width: 100%; text-align: center; font-size: 1.1em; margin-bottom: 15px;">
                                ìƒˆë¡œìš´ ê²Œì„ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...
                            </p>
                            <button class="btn btn-cancel-waiting" onclick="game.leaveRoomAndCloseModal()">ë‚˜ê°€ê¸°</button>
                        `;
                    } else {
                        // ì§„ ì‚¬ëŒ: "ìƒˆë¡œìš´ ê²Œì„ì„ ìš”ì²­í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ìˆ˜ë½/ë‚˜ê°€ê¸°"
                        modalButtons.innerHTML = `
                            <p style="width: 100%; text-align: center; font-size: 1.1em; margin-bottom: 15px;">
                                ìƒˆë¡œìš´ ê²Œì„ì„ ìš”ì²­í•˜ì‹œê² ìŠµë‹ˆê¹Œ?
                            </p>
                            <button class="btn btn-mode" onclick="game.requestRematch()">ìˆ˜ë½</button>
                            <button class="btn btn-cancel-waiting" onclick="game.leaveRoomAndCloseModal()">ë‚˜ê°€ê¸°</button>
                        `;
                    }
                } else {
                    // ë¡œì»¬ ëª¨ë“œ: í™•ì¸ ë²„íŠ¼ë§Œ
                    modalButtons.innerHTML = `
                        <button class="btn btn-restart" onclick="game.closeModal()">í™•ì¸</button>
                    `;
                }

                document.getElementById('winnerModal').classList.add('active');

                // ì˜¨ë¼ì¸ ëª¨ë“œì—ì„œ ì¬ê²½ê¸° ìš”ì²­ ê°ì§€ ì‹œì‘
                if (this.isOnlineMode && this.roomSystem) {
                    this.startRematchPolling();
                }
            }

            // í™”ë ¤í•œ ìŠ¹ë¦¬ ì„¸ë ˆëª¨ë‹ˆ
            showVictoryCeremony(winner, detail) {
                const modalContent = document.getElementById('modalContent');
                modalContent.classList.add('victory');

                // ìŠ¹ì ì•„ì´ì½˜ ë³€ê²½
                const winnerIcon = document.getElementById('winnerIcon');
                winnerIcon.textContent = 'ğŸ†';

                // í­ì£½ íš¨ê³¼
                this.createConfetti();

                // ë¶ˆê½ƒë†€ì´ íš¨ê³¼
                this.createFireworks();

                // 3ì´ˆ í›„ íš¨ê³¼ ì •ë¦¬
                setTimeout(() => {
                    document.getElementById('confettiContainer').innerHTML = '';
                }, 5000);
            }

            // í­ì£½ ìƒì„±
            createConfetti() {
                const container = document.getElementById('confettiContainer');
                const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F'];

                for (let i = 0; i < 150; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDelay = Math.random() * 3 + 's';
                    confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';

                    container.appendChild(confetti);

                    // 3ì´ˆ í›„ ì œê±°
                    setTimeout(() => confetti.remove(), 5000);
                }
            }

            // ë¶ˆê½ƒë†€ì´ íš¨ê³¼
            createFireworks() {
                const container = document.getElementById('confettiContainer');
                const colors = ['#FFD700', '#FF1493', '#00CED1', '#FF4500', '#9370DB'];

                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const x = Math.random() * window.innerWidth;
                        const y = Math.random() * window.innerHeight * 0.5;

                        for (let j = 0; j < 30; j++) {
                            const firework = document.createElement('div');
                            firework.className = 'firework';
                            firework.style.left = x + 'px';
                            firework.style.top = y + 'px';
                            firework.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];

                            const angle = (j / 30) * 2 * Math.PI;
                            const velocity = 50 + Math.random() * 50;
                            const tx = Math.cos(angle) * velocity;
                            const ty = Math.sin(angle) * velocity;

                            firework.style.setProperty('--tx', tx + 'px');
                            firework.style.setProperty('--ty', ty + 'px');

                            container.appendChild(firework);

                            setTimeout(() => firework.remove(), 1000);
                        }
                    }, i * 600);
                }
            }

            // ëª¨ë‹¬ ë‹«ê¸°
            closeModal() {
                const modalContent = document.getElementById('modalContent');
                modalContent.classList.remove('victory');
                document.getElementById('winnerModal').classList.remove('active');
                document.getElementById('confettiContainer').innerHTML = '';
            }

            // ===== í„´ íƒ€ì´ë¨¸ ì‹œìŠ¤í…œ =====

            // íƒ€ì´ë¨¸ ì‹œì‘
            startTimer() {
                if (!this.timerEnabled) return;

                // ê¸°ì¡´ íƒ€ì´ë¨¸ ì •ë¦¬
                this.stopTimer();

                // íƒ€ì´ë¨¸ í‘œì‹œ
                document.getElementById('turnTimer').style.display = 'block';

                // ì‹œê°„ ì´ˆê¸°í™”
                this.currentTurnTime = this.turnTimeLimit;
                this.updateTimerDisplay();

                // 1ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
                this.timerInterval = setInterval(() => {
                    this.currentTurnTime--;
                    this.updateTimerDisplay();

                    if (this.currentTurnTime <= 0) {
                        // ì‹œê°„ ì´ˆê³¼ - ìë™ íŒ¨ìŠ¤
                        this.onTimeOut();
                    }
                }, 1000);
            }

            // íƒ€ì´ë¨¸ ì •ì§€
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }

            // íƒ€ì´ë¨¸ í‘œì‹œ ì—…ë°ì´íŠ¸
            updateTimerDisplay() {
                const display = document.getElementById('timerDisplay');
                const progressBar = document.getElementById('timerProgressBar');

                // ìˆ«ì í‘œì‹œ
                display.textContent = this.currentTurnTime;

                // ì§„í–‰ë°” ì—…ë°ì´íŠ¸
                const percentage = (this.currentTurnTime / this.turnTimeLimit) * 100;
                progressBar.style.width = percentage + '%';

                // ìƒ‰ìƒ ë³€ê²½
                display.className = 'timer-display';
                progressBar.className = 'timer-progress-bar';

                if (this.currentTurnTime <= 3) {
                    // 3ì´ˆ ì´í•˜ - ìœ„í—˜ (ë¹¨ê°„ìƒ‰, í”ë“¤ë¦¼)
                    display.classList.add('danger');
                    progressBar.classList.add('danger');
                } else if (this.currentTurnTime <= 5) {
                    // 5ì´ˆ ì´í•˜ - ê²½ê³  (ë…¸ë€ìƒ‰, ê¹œë¹¡ì„)
                    display.classList.add('warning');
                    progressBar.classList.add('warning');
                }
            }

            // ì‹œê°„ ì´ˆê³¼ ì²˜ë¦¬
            async onTimeOut() {
                this.stopTimer();

                // ì˜¨ë¼ì¸ ëª¨ë“œì¸ ê²½ìš°
                if (this.isOnlineMode && this.roomSystem) {
                    // ë‚´ í„´ì¸ì§€ í™•ì¸
                    const isMyTurn = this.currentPlayer === this.myOnlineColor;

                    if (isMyTurn) {
                        // ë‚´ í„´ì— ì‹œê°„ ì´ˆê³¼ â†’ AIê°€ ëŒ€ì‹  ë‘ 
                        if (!this.isAISubstituting) {
                            this.addLog(`â±ï¸ ì‹œê°„ ì´ˆê³¼! ì»´í“¨í„°ê°€ ëŒ€ì‹  í”Œë ˆì´í•©ë‹ˆë‹¤.`);
                            // ê²½ê³  í‘œì‹œ (ì²˜ìŒ í•œ ë²ˆë§Œ)
                            this.showConnectionWarning();
                        }

                        // AIê°€ ìë™ìœ¼ë¡œ ë§ì„ ë‘ 
                        const move = await this.getAIMove(this.difficulty || 'medium');
                        if (move) {
                            // AIê°€ ë§ì„ ë‘ê³  ìƒëŒ€ì—ê²Œ ì „ì†¡
                            await this.placeStone(move.row, move.col, true);
                        } else {
                            // AIë„ ë‘˜ ê³³ì´ ì—†ìœ¼ë©´ íŒ¨ìŠ¤
                            try {
                                await this.roomSystem.sendMove('pass', -1, -1, {});
                            } catch (error) {
                                console.error('íŒ¨ìŠ¤ ì „ì†¡ ì‹¤íŒ¨:', error);
                            }
                            this.pass();
                        }
                    } else {
                        // ìƒëŒ€ í„´ì— ì‹œê°„ ì´ˆê³¼ â†’ ìƒëŒ€ê°€ AI ëŒ€íƒ€ë¡œ ë‘ëŠ” ì¤‘
                        this.addLog(`â±ï¸ ìƒëŒ€ë°© ì‹œê°„ ì´ˆê³¼! ì ì‹œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”...`);
                        // ìƒëŒ€ë°©ì´ AIë¡œ ë‘˜ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
                    }
                } else {
                    // ë¡œì»¬ ëª¨ë“œ - ìë™ íŒ¨ìŠ¤
                    this.addLog(`â±ï¸ ${this.currentPlayer === 'blue' ? 'ğŸ”µ íŒŒë€ìƒ‰' : 'ğŸŸ  ì£¼í™©ìƒ‰'} ì‹œê°„ ì´ˆê³¼! ìë™ íŒ¨ìŠ¤ë©ë‹ˆë‹¤.`);
                    this.pass();
                }
            }

            // íƒ€ì´ë¨¸ í™œì„±í™”/ë¹„í™œì„±í™”
            enableTimer(enabled) {
                this.timerEnabled = enabled;

                if (enabled) {
                    document.getElementById('turnTimer').style.display = 'block';
                    this.startTimer();
                } else {
                    document.getElementById('turnTimer').style.display = 'none';
                    this.stopTimer();
                }
            }

            // ===== ì˜¨ë¼ì¸ ë°© ì‹œìŠ¤í…œ =====

            // ì˜¨ë¼ì¸ ëŒ€ì „ ì‹œì‘ (ë°© ì„ íƒ ëª¨ë‹¬ í‘œì‹œ)
            async startOnlineMatch() {
                try {
                    // í”Œë ˆì´ì–´ ì´ë¦„ ì…ë ¥
                    const playerName = prompt('í”Œë ˆì´ì–´ ì´ë¦„ì„ ì…ë ¥í•˜ì„¸ìš”:', `í”Œë ˆì´ì–´${Math.floor(Math.random() * 1000)}`);
                    if (!playerName) return;

                    this.playerName = playerName;

                    // ì˜¨ë¼ì¸ ë°© ì‹œìŠ¤í…œ ê°ì²´ ìƒì„±
                    if (!this.roomSystem) {
                        this.roomSystem = new OnlineRoomSystem(SUPABASE_URL, SUPABASE_KEY);
                    }

                    // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡
                    this.roomSystem.onOpponentMove = (move) => {
                        this.handleOpponentMove(move);
                    };

                    this.roomSystem.onRoomReady = (room) => {
                        this.onRoomReady(room);
                    };

                    this.roomSystem.onOpponentDisconnected = () => {
                        this.showOpponentDisconnectedWarning();
                    };

                    // ë°© ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸° ë° ëª¨ë‹¬ í‘œì‹œ
                    await this.showRoomSelection();

                } catch (error) {
                    console.error('ì˜¨ë¼ì¸ ëŒ€ì „ ì‹œì‘ ì˜¤ë¥˜:', error);
                    alert('ì˜¨ë¼ì¸ ëŒ€ì „ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                }
            }

            // ë°© ì„ íƒ í™”ë©´ í‘œì‹œ
            async showRoomSelection() {
                const modal = document.getElementById('roomModal');
                const roomSelection = document.getElementById('roomSelection');

                // ë°© ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
                const rooms = await this.roomSystem.getAllRooms();

                // ë°© ì¹´ë“œ ìƒì„±
                roomSelection.innerHTML = '';
                rooms.forEach(room => {
                    const card = document.createElement('div');
                    card.className = 'room-card';

                    // ë°© ìƒíƒœì— ë”°ë¼ í´ë˜ìŠ¤ ì¶”ê°€
                    if (room.status === 'playing') {
                        card.classList.add('playing');
                    } else if (room.player1_session && !room.player2_session) {
                        card.classList.add('waiting');
                    } else if (room.player1_session && room.player2_session) {
                        card.classList.add('full');
                    }

                    // ë°© ì •ë³´ í‘œì‹œ
                    const statusText = room.status === 'playing' ? 'ê²Œì„ ì¤‘' :
                                      room.player1_session && room.player2_session ? 'ì¸ì› ì´ˆê³¼' :
                                      room.player1_session ? 'ëŒ€ê¸° ì¤‘ (1/2)' :
                                      'ë¹„ì–´ìˆìŒ (0/2)';

                    const playersText = [room.player1_name, room.player2_name].filter(Boolean).join(', ') || 'ì—†ìŒ';

                    card.innerHTML = `
                        <div class="room-number">${room.room_number}ë²ˆ ë°©</div>
                        <div class="room-status">${statusText}</div>
                        <div class="room-players">í”Œë ˆì´ì–´: ${playersText}</div>
                    `;

                    // í´ë¦­ ì´ë²¤íŠ¸ (ë¹„ì–´ìˆê±°ë‚˜ 1ëª…ë§Œ ìˆëŠ” ë°©ë§Œ ì…ì¥ ê°€ëŠ¥)
                    if (room.status !== 'playing' && !(room.player1_session && room.player2_session)) {
                        card.onclick = () => this.joinRoom(room.room_number);
                    } else {
                        card.style.cursor = 'not-allowed';
                    }

                    roomSelection.appendChild(card);
                });

                // ëª¨ë‹¬ í‘œì‹œ
                modal.classList.add('active');

                // 1ì´ˆë§ˆë‹¤ ë°© ëª©ë¡ ìƒˆë¡œê³ ì¹¨
                this.roomRefreshInterval = setInterval(async () => {
                    if (modal.classList.contains('active')) {
                        await this.showRoomSelection();
                    } else {
                        clearInterval(this.roomRefreshInterval);
                    }
                }, 2000);
            }

            // ë°© ì…ì¥
            async joinRoom(roomNumber) {
                try {
                    // ë°© ì…ì¥
                    const result = await this.roomSystem.joinRoom(roomNumber, this.playerName);

                    // ê²Œì„ ëª¨ë“œ ì„¤ì •
                    this.isOnlineMode = true;
                    this.myOnlineColor = result.myColor;
                    this.gameMode = 'online';

                    // ëª¨ë‹¬ì„ ëŒ€ê¸° í™”ë©´ìœ¼ë¡œ ë³€ê²½ (ë‹«ì§€ ì•ŠìŒ)
                    const modal = document.getElementById('roomModal');
                    const modalContent = modal.querySelector('.modal-content');
                    modalContent.innerHTML = `
                        <h2>ğŸ® ${roomNumber}ë²ˆ ë°©</h2>
                        <p style="font-size: 1.2em; color: #666;">
                            ${result.waiting ? 'â³ ìƒëŒ€ í”Œë ˆì´ì–´ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...' : 'âœ… ë§¤ì¹­ ì™„ë£Œ!'}
                        </p>
                        <div style="margin: 30px 0; padding: 20px; background: #f0f4ff; border-radius: 10px;">
                            <div style="font-size: 1.1em; margin-bottom: 10px;">
                                <strong>ë‚´ ìƒ‰ìƒ:</strong> ${this.myOnlineColor === 'blue' ? 'ğŸ”µ íŒŒë€ìƒ‰ (ì„ ê³µ)' : 'ğŸŸ  ì£¼í™©ìƒ‰ (í›„ê³µ)'}
                            </div>
                            ${result.waiting ?
                                '<div style="font-size: 0.9em; color: #888;">ìƒëŒ€ë¥¼ ê¸°ë‹¤ë¦¬ê³  ìˆìŠµë‹ˆë‹¤...</div>' :
                                `<div style="font-size: 1.1em;"><strong>ìƒëŒ€:</strong> ${result.opponentName}</div>`
                            }
                        </div>
                        <button class="btn btn-cancel-waiting" onclick="game.leaveRoomAndClose()" style="margin-top: 20px;">
                            ë‚˜ê°€ê¸°
                        </button>
                    `;

                    // ë°© ëª©ë¡ ìƒˆë¡œê³ ì¹¨ ì¤‘ë‹¨
                    if (this.roomRefreshInterval) {
                        clearInterval(this.roomRefreshInterval);
                    }

                    // ì˜¨ë¼ì¸ ìƒíƒœ í‘œì‹œ
                    document.getElementById('onlineStatus').style.display = 'block';
                    document.getElementById('onlineRoomInfo').innerHTML = `
                        ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „ ì¤‘ (${roomNumber}ë²ˆ ë°©)<br>
                        ë‚´ ìƒ‰ìƒ: ${this.myOnlineColor === 'blue' ? 'ğŸ”µ íŒŒë€ìƒ‰ (ì„ ê³µ)' : 'ğŸŸ  ì£¼í™©ìƒ‰ (í›„ê³µ)'}<br>
                        ${result.waiting ? 'â³ ìƒëŒ€ ëŒ€ê¸° ì¤‘...' : `vs ${result.opponentName}`}
                    `;

                    this.addLog(`âœ… ${roomNumber}ë²ˆ ë°©ì— ì…ì¥í–ˆìŠµë‹ˆë‹¤.`);
                    this.addLog(`ë‹¹ì‹ ì€ ${this.myOnlineColor === 'blue' ? 'ğŸ”µ íŒŒë€ìƒ‰ (ì„ ê³µ)' : 'ğŸŸ  ì£¼í™©ìƒ‰ (í›„ê³µ)'} ì…ë‹ˆë‹¤.`);

                    if (!result.waiting) {
                        // ì¦‰ì‹œ 2ëª… ë§¤ì¹­ ì™„ë£Œ
                        this.addLog(`ğŸ® ìƒëŒ€: ${result.opponentName}`);
                    }

                } catch (error) {
                    console.error('ë°© ì…ì¥ ì˜¤ë¥˜:', error);
                    alert(error.message || 'ë°© ì…ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            }

            // ë°© ë‚˜ê°€ê¸° ë° ëª¨ë‹¬ ë‹«ê¸°
            async leaveRoomAndClose() {
                await this.leaveRoom();
                document.getElementById('roomModal').classList.remove('active');
            }

            // ë°© ë‚˜ê°€ê¸°
            async leaveRoom() {
                if (this.roomSystem && this.roomSystem.currentRoom) {
                    await this.roomSystem.leaveRoom();
                    this.isOnlineMode = false;
                    this.gameMode = 'pvp';
                    this.enableTimer(false);
                    document.getElementById('onlineStatus').style.display = 'none';
                    this.addLog('ë°©ì—ì„œ ë‚˜ê°”ìŠµë‹ˆë‹¤.');
                }
            }

            // ë°©ì´ ì¤€ë¹„ë¨ (2ëª… ëª¨ë‘ ì…ì¥)
            async onRoomReady(room) {
                // ëª¨ë‹¬ ë‹«ê¸°
                document.getElementById('roomModal').classList.remove('active');

                // 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´
                await this.showCountdown();

                // ê²Œì„ ì‹œì‘
                await this.roomSystem.startGame();

                // íƒ€ì´ë¨¸ í™œì„±í™”
                this.enableTimer(true);

                // ìƒíƒœ ì—…ë°ì´íŠ¸
                const opponentName = this.myOnlineColor === 'blue' ? room.player2_name : room.player1_name;
                document.getElementById('onlineRoomInfo').innerHTML = `
                    ğŸŒ ì˜¨ë¼ì¸ ëŒ€ì „ ì¤‘ (${room.room_number}ë²ˆ ë°©)<br>
                    ë‚´ ìƒ‰ìƒ: ${this.myOnlineColor === 'blue' ? 'ğŸ”µ íŒŒë€ìƒ‰ (ì„ ê³µ)' : 'ğŸŸ  ì£¼í™©ìƒ‰ (í›„ê³µ)'}<br>
                    vs ${opponentName}
                `;

                this.addLog(`ğŸ® ê²Œì„ ì‹œì‘! ìƒëŒ€: ${opponentName}`);
                this.addLog(`â±ï¸ í„´ë‹¹ ${this.turnTimeLimit}ì´ˆ ì‹œê°„ì œí•œì´ ì ìš©ë©ë‹ˆë‹¤.`);

                // ê²Œì„ ì¬ì‹œì‘
                this.restart();
            }

            // ì¹´ìš´íŠ¸ë‹¤ìš´ í‘œì‹œ
            async showCountdown() {
                const overlay = document.getElementById('countdownOverlay');
                const number = document.getElementById('countdownNumber');

                overlay.classList.add('active');

                for (let i = 3; i >= 1; i--) {
                    number.textContent = i;
                    number.style.animation = 'none';
                    setTimeout(() => { number.style.animation = 'countdown-pulse 1s ease-in-out'; }, 10);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                overlay.classList.remove('active');
            }

            // íƒ€ì„ì•„ì›ƒ ê²½ê³  í‘œì‹œ
            showConnectionWarning() {
                const warning = document.getElementById('connectionWarning');
                const message = document.getElementById('warningMessage');

                message.textContent = 'âš ï¸ ì‹œê°„ ì´ˆê³¼! ì»´í“¨í„°ê°€ ëŒ€ì‹  í”Œë ˆì´ ì¤‘ì…ë‹ˆë‹¤.';
                warning.classList.add('active');

                this.isAISubstituting = true;
            }

            // ìƒëŒ€ë°© ì—°ê²° ëŠê¹€ ê²½ê³  í‘œì‹œ
            showOpponentDisconnectedWarning() {
                const warning = document.getElementById('connectionWarning');
                const message = document.getElementById('warningMessage');

                message.textContent = 'âš ï¸ ìƒëŒ€ë°©ì˜ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. AIê°€ ëŒ€ì‹  í”Œë ˆì´ ì¤‘ì…ë‹ˆë‹¤.';
                warning.classList.add('active');
            }

            // ìˆ˜ë™ í”Œë ˆì´ ì¬ê°œ
            resumeManualPlay() {
                const warning = document.getElementById('connectionWarning');
                warning.classList.remove('active');

                this.isAISubstituting = false;

                this.addLog('âœ… ë‹¤ì‹œ ì§ì ‘ í”Œë ˆì´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');

                // ë‹¤ìŒ í„´ë¶€í„°ëŠ” ì§ì ‘ ë‘ë„ë¡ ì„¤ì •
                if (this.currentPlayer === this.myOnlineColor && this.timerEnabled) {
                    this.startTimer();
                }
            }

            // ë°© ì„ íƒ ëª¨ë‹¬ ë‹«ê¸°
            closeRoomModal() {
                document.getElementById('roomModal').classList.remove('active');
                if (this.roomRefreshInterval) {
                    clearInterval(this.roomRefreshInterval);
                }
            }

            // ì¬ê²½ê¸° ìš”ì²­ (ì§„ ì‚¬ëŒì´ ë³´ëƒ„)
            async requestRematch() {
                if (!this.roomSystem || !this.roomSystem.currentRoom) return;

                try {
                    await this.roomSystem.requestRematch(this.roomSystem.sessionId);

                    // UI ì—…ë°ì´íŠ¸
                    const modalButtons = document.getElementById('modalButtons');
                    modalButtons.innerHTML = `
                        <p style="width: 100%; text-align: center; font-size: 1.1em; margin-bottom: 15px;">
                            ì¬ê²½ê¸° ìš”ì²­ì„ ë³´ëƒˆìŠµë‹ˆë‹¤. ìƒëŒ€ë°©ì˜ ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘...
                        </p>
                        <button class="btn btn-cancel-waiting" onclick="game.cancelRematch()">ì·¨ì†Œ</button>
                    `;

                    this.addLog('ğŸ”„ ì¬ê²½ê¸°ë¥¼ ìš”ì²­í–ˆìŠµë‹ˆë‹¤.');
                } catch (error) {
                    console.error('ì¬ê²½ê¸° ìš”ì²­ ì˜¤ë¥˜:', error);
                    alert('ì¬ê²½ê¸° ìš”ì²­ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            }

            // ì¬ê²½ê¸° ìˆ˜ë½ (ì´ê¸´ ì‚¬ëŒì´ ìˆ˜ë½)
            async acceptRematch() {
                if (!this.roomSystem || !this.roomSystem.currentRoom) return;

                try {
                    await this.roomSystem.acceptRematch();

                    this.addLog('âœ… ì¬ê²½ê¸°ë¥¼ ìˆ˜ë½í–ˆìŠµë‹ˆë‹¤.');

                    // ëª¨ë‹¬ ë‹«ê³  ê²Œì„ ì¬ì‹œì‘
                    this.closeModal();
                    await this.startNewGame();
                } catch (error) {
                    console.error('ì¬ê²½ê¸° ìˆ˜ë½ ì˜¤ë¥˜:', error);
                    alert('ì¬ê²½ê¸° ìˆ˜ë½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            }

            // ì¬ê²½ê¸° ê±°ì ˆ
            async declineRematch() {
                if (!this.roomSystem || !this.roomSystem.currentRoom) return;

                try {
                    await this.roomSystem.declineRematch();
                    this.addLog('âŒ ì¬ê²½ê¸°ë¥¼ ê±°ì ˆí–ˆìŠµë‹ˆë‹¤.');
                    await this.leaveRoomAndCloseModal();
                } catch (error) {
                    console.error('ì¬ê²½ê¸° ê±°ì ˆ ì˜¤ë¥˜:', error);
                }
            }

            // ì¬ê²½ê¸° ì·¨ì†Œ
            async cancelRematch() {
                if (!this.roomSystem || !this.roomSystem.currentRoom) return;

                try {
                    await this.roomSystem.cancelRematch();
                    this.addLog('ğŸš« ì¬ê²½ê¸° ìš”ì²­ì„ ì·¨ì†Œí–ˆìŠµë‹ˆë‹¤.');
                    await this.leaveRoomAndCloseModal();
                } catch (error) {
                    console.error('ì¬ê²½ê¸° ì·¨ì†Œ ì˜¤ë¥˜:', error);
                }
            }

            // ì¬ê²½ê¸° ìƒíƒœ í´ë§ ì‹œì‘
            startRematchPolling() {
                if (this.rematchPollingInterval) {
                    clearInterval(this.rematchPollingInterval);
                }

                this.rematchPollingInterval = setInterval(async () => {
                    await this.checkRematchStatus();
                }, 1000);
            }

            // ì¬ê²½ê¸° ìƒíƒœ í™•ì¸
            async checkRematchStatus() {
                if (!this.roomSystem || !this.roomSystem.currentRoom) {
                    clearInterval(this.rematchPollingInterval);
                    return;
                }

                try {
                    const status = await this.roomSystem.getRematchStatus();

                    if (status.rematch_status === 'requested') {
                        // ì¬ê²½ê¸° ìš”ì²­ì´ ë“¤ì–´ì˜´ (ì´ê¸´ ì‚¬ëŒ)
                        const modalButtons = document.getElementById('modalButtons');
                        modalButtons.innerHTML = `
                            <p style="width: 100%; text-align: center; font-size: 1.1em; margin-bottom: 15px;">
                                ìƒˆë¡œìš´ ê²Œì„ ìš”ì²­ì´ ì™”ìŠµë‹ˆë‹¤!
                            </p>
                            <button class="btn btn-mode" onclick="game.acceptRematch()">ìˆ˜ë½</button>
                            <button class="btn btn-cancel-waiting" onclick="game.declineRematch()">ë‚˜ê°€ê¸°</button>
                        `;
                        this.addLog('ğŸ”” ìƒëŒ€ë°©ì´ ì¬ê²½ê¸°ë¥¼ ìš”ì²­í–ˆìŠµë‹ˆë‹¤!');
                    } else if (status.rematch_status === 'accepted') {
                        // ì¬ê²½ê¸° ìˆ˜ë½ë¨
                        clearInterval(this.rematchPollingInterval);
                        this.closeModal();
                        await this.startNewGame();
                    } else if (status.rematch_status === 'declined') {
                        // ì¬ê²½ê¸° ê±°ì ˆë¨
                        clearInterval(this.rematchPollingInterval);
                        alert('ìƒëŒ€ë°©ì´ ì¬ê²½ê¸°ë¥¼ ê±°ì ˆí–ˆìŠµë‹ˆë‹¤.');
                        await this.leaveRoomAndCloseModal();
                    }
                } catch (error) {
                    console.error('ì¬ê²½ê¸° ìƒíƒœ í™•ì¸ ì˜¤ë¥˜:', error);
                }
            }

            // ìƒˆ ê²Œì„ ì‹œì‘
            async startNewGame() {
                this.addLog('ğŸ® ìƒˆ ê²Œì„ì„ ì‹œì‘í•©ë‹ˆë‹¤!');

                // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
                this.board = Array(9).fill(null).map(() => Array(9).fill(null));
                this.board[4][4] = 'neutral';
                this.currentPlayer = 'blue';
                this.blueStones = 40;
                this.orangeStones = 40;
                this.consecutivePasses = 0;
                this.gameOver = false;
                this.moveHistory = [];
                this.isAISubstituting = false;

                // ë°© ìƒíƒœë¥¼ playingìœ¼ë¡œ ì¬ì„¤ì •
                if (this.roomSystem) {
                    await this.roomSystem.resetGameForRematch();
                }

                // UI ì—…ë°ì´íŠ¸
                this.renderBoard();
                this.updateUI();

                // íƒ€ì´ë¨¸ ì¬ì‹œì‘
                if (this.timerEnabled) {
                    this.startTimer();
                }
            }

            // ë°© ë‚˜ê°€ê¸° ë° ëª¨ë‹¬ ë‹«ê¸°
            async leaveRoomAndCloseModal() {
                if (this.rematchPollingInterval) {
                    clearInterval(this.rematchPollingInterval);
                }
                await this.leaveRoom();
                this.closeModal();
            }

            // ìƒëŒ€ ì´ë™ ì²˜ë¦¬
            handleOpponentMove(move) {
                console.log('[Game] ìƒëŒ€ ì´ë™ ìˆ˜ì‹ :', move);

                if (move.move_type === 'place') {
                    // ìƒëŒ€ê°€ ë§ì„ ë†“ìŒ
                    this.placeStone(move.row_pos, move.col_pos, false); // ì „ì†¡í•˜ì§€ ì•ŠìŒ
                } else if (move.move_type === 'pass') {
                    // ìƒëŒ€ê°€ íŒ¨ìŠ¤
                    this.pass();
                }
            }

            // ê²Œì„ ì¬ì‹œì‘
            restart() {
                this.board = Array(9).fill(null).map(() => Array(9).fill(null));
                this.board[4][4] = 'neutral';
                this.currentPlayer = 'blue';
                this.blueStones = 40;
                this.orangeStones = 40;
                this.consecutivePasses = 0;
                this.gameOver = false;
                this.moveHistory = [];

                // íƒ€ì´ë¨¸ ì¬ì‹œì‘
                if (this.timerEnabled) {
                    this.startTimer();
                }

                document.getElementById('gameLog').innerHTML = '<div class="log-entry">ê²Œì„ ì¬ì‹œì‘!</div>';
                this.closeModal();
                this.renderBoard();
                this.updateUI();
            }

            // UI ì—…ë°ì´íŠ¸
            updateUI() {
                const turnElement = document.getElementById('currentTurn');
                turnElement.className = `current-turn ${this.currentPlayer}-turn`;
                turnElement.textContent = `${this.currentPlayer === 'blue' ? 'ğŸ”µ íŒŒë€ìƒ‰' : 'ğŸŸ  ì£¼í™©ìƒ‰'} ì°¨ë¡€`;

                document.getElementById('blueStones').textContent = `${this.blueStones}ê°œ ë‚¨ìŒ`;
                document.getElementById('orangeStones').textContent = `${this.orangeStones}ê°œ ë‚¨ìŒ`;
            }

            // ë¡œê·¸ ì¶”ê°€
            addLog(message) {
                const logElement = document.getElementById('gameLog');
                const entry = document.createElement('div');
                entry.className = 'log-entry';
                entry.textContent = message;
                logElement.insertBefore(entry, logElement.firstChild);
            }
        }

        // ê²Œì„ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
        const game = new GreatKingdomGame();

        // ===== AI ì‹œìŠ¤í…œ ì™„ì „ ì¬êµ¬ì¶• =====
        
        // ë‚œì´ë„ ì„¤ì • í•¨ìˆ˜
        game.setDifficulty = function(difficulty) {
            this.aiDifficulty = difficulty;
            
            // ë²„íŠ¼ í™œì„±í™” ìƒíƒœ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.btn-difficulty').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const difficultyInfo = {
                'easy': {
                    text: 'ğŸ˜Š ì‰¬ì›€ ë‹¨ê³„<br>- ê¸°ë³¸ì ì¸ ì „ëµë§Œ ì‚¬ìš©<br>- ì´ˆë³´ìì—ê²Œ ì í•©',
                    color: '#2ecc71'
                },
                'medium': {
                    text: 'ğŸ¤” ë³´í†µ ë‹¨ê³„<br>- 2ìˆ˜ ì•ì„ ë‚´ë‹¤ë´„<br>- ê³µê²©ê³¼ ë°©ì–´ ê· í˜•',
                    color: '#f39c12'
                },
                'hard': {
                    text: 'ğŸ˜ˆ ì–´ë ¤ì›€ ë‹¨ê³„<br>- 4ìˆ˜ ì•ì„ ë‚´ë‹¤ë´„<br>- ê³ ê¸‰ ì „ëµ ì‚¬ìš©<br>- ì´ê¸°ê¸° ë§¤ìš° ì–´ë ¤ì›€',
                    color: '#e74c3c'
                }
            };
            
            const info = difficultyInfo[difficulty];
            document.getElementById('difficultyInfo').innerHTML = info.text;
            document.getElementById('difficultyInfo').style.borderLeft = `3px solid ${info.color}`;
            document.getElementById('difficultyInfo').style.paddingLeft = '10px';
            
            // í•´ë‹¹ ë²„íŠ¼ í™œì„±í™”
            const buttons = {
                'easy': '.btn-easy',
                'medium': '.btn-medium',
                'hard': '.btn-hard'
            };
            document.querySelector(buttons[difficulty]).classList.add('active');
            
            this.addLog(`ë‚œì´ë„ ë³€ê²½: ${difficulty === 'easy' ? 'ğŸ˜Š ì‰¬ì›€' : difficulty === 'medium' ? 'ğŸ¤” ë³´í†µ' : 'ğŸ˜ˆ ì–´ë ¤ì›€'}`);
            this.restart();
        };
        
        // setMode í•¨ìˆ˜ ì¬ì •ì˜
        game.setMode = function(mode) {
            this.gameMode = mode;
            const aiPanel = document.getElementById('aiDifficultyPanel');
            
            if (mode === 'ai') {
                aiPanel.style.display = 'block';
                this.addLog(`ğŸ¤– ì»´í“¨í„° ëŒ€ì „ ëª¨ë“œ ì„ íƒ`);
                // ê¸°ë³¸ ë‚œì´ë„ ë³´í†µìœ¼ë¡œ ì„¤ì •
                if (!document.querySelector('.btn-difficulty.active')) {
                    this.setDifficulty('medium');
                }
            } else {
                aiPanel.style.display = 'none';
                this.addLog('ğŸ‘¥ ëŒ€ì¸ ê²½ê¸° ëª¨ë“œ');
            }
            
            this.restart();
        };

        // AI ì´ë™ í•¨ìˆ˜ ì™„ì „ ì¬êµ¬ì¶•
        game.aiMove = function() {
            const validMoves = this.getValidMoves();
            
            if (validMoves.length === 0) {
                this.pass();
                return;
            }

            let selectedMove;
            
            switch(this.aiDifficulty) {
                case 'easy':
                    selectedMove = this.aiMoveEasy(validMoves);
                    break;
                case 'medium':
                    selectedMove = this.aiMoveMedium(validMoves);
                    break;
                case 'hard':
                    selectedMove = this.aiMoveHard(validMoves);
                    break;
                default:
                    selectedMove = this.aiMoveMedium(validMoves);
            }
            
            if (selectedMove) {
                this.placeStone(selectedMove[0], selectedMove[1]);
            } else {
                this.pass();
            }
        };

        // ì‰¬ì›€ AI: ê¸°ë³¸ ì „ëµ
        game.aiMoveEasy = function(validMoves) {
            // 1. ìƒëŒ€ë¥¼ ì¡ì„ ìˆ˜ ìˆëŠ” ìˆ˜ê°€ ìˆìœ¼ë©´ ê·¸ê±¸ ë‘ 
            for (const move of validMoves) {
                const [row, col] = move;
                this.board[row][col] = 'orange';
                const captured = this.checkCapture(row, col);
                this.board[row][col] = null;
                
                if (captured.length > 0) {
                    return move; // ì¦‰ì‹œ ì¡ì„ ìˆ˜ ìˆìœ¼ë©´ ê·¸ ìˆ˜ë¥¼ ë‘”ë‹¤
                }
            }
            
            // 2. ê¸°ë³¸ ì ìˆ˜ í‰ê°€
            const scored = validMoves.map(move => {
                let score = 0;
                const [row, col] = move;
                
                // ì£¼ë³€ í™•ì¸
                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                for (const [dr, dc] of directions) {
                    const nr = row + dr;
                    const nc = col + dc;
                    if (this.isValidCell(nr, nc)) {
                        if (this.board[nr][nc] === 'blue') score += 3; // ìƒëŒ€ ê·¼ì²˜
                        if (this.board[nr][nc] === 'orange') score += 2; // ë‚´ ë§ ê·¼ì²˜
                        if (this.board[nr][nc] === null) score += 1; // ë¹ˆ ê³µê°„
                    }
                }
                
                // ì¤‘ì•™ ì„ í˜¸
                const centerDist = Math.abs(row - 4) + Math.abs(col - 4);
                score += (8 - centerDist);
                
                return { move, score };
            });

            scored.sort((a, b) => b.score - a.score);
            const topMoves = scored.slice(0, Math.max(1, Math.floor(scored.length * 0.3)));
            return topMoves[Math.floor(Math.random() * topMoves.length)].move;
        };

        // ë³´í†µ AI: 2ìˆ˜ ì•ì„ ë´„
        game.aiMoveMedium = function(validMoves) {
            // 1. ìƒëŒ€ë¥¼ ì¡ì„ ìˆ˜ ìˆëŠ” ìˆ˜
            for (const move of validMoves) {
                const [row, col] = move;
                this.board[row][col] = 'orange';
                const captured = this.checkCapture(row, col);
                this.board[row][col] = null;
                
                if (captured.length > 0) {
                    return move;
                }
            }
            
            // 2. ë‚´ê°€ ì¡íˆëŠ”ì§€ í™•ì¸ (ë°©ì–´)
            const defenseMoves = [];
            for (const move of validMoves) {
                const [row, col] = move;
                let willBeCaptured = false;
                
                // ì´ ìˆ˜ë¥¼ ë‘ë©´ ë‚´ê°€ ì¡íˆëŠ”ì§€ ì‹œë®¬ë ˆì´ì…˜
                this.board[row][col] = 'orange';
                
                // ìƒëŒ€ê°€ ë‹¤ìŒ ìˆ˜ì—ì„œ ë‚˜ë¥¼ ì¡ì„ ìˆ˜ ìˆëŠ”ì§€ í™•ì¸
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.board[r][c] === null) {
                            this.board[r][c] = 'blue';
                            const tempCapture = this.checkCapture(r, c);
                            this.board[r][c] = null;
                            
                            if (tempCapture.some(([cr, cc]) => cr === row && cc === col)) {
                                willBeCaptured = true;
                                break;
                            }
                        }
                    }
                    if (willBeCaptured) break;
                }
                
                this.board[row][col] = null;
                
                if (!willBeCaptured) {
                    defenseMoves.push(move);
                }
            }
            
            // ì•ˆì „í•œ ìˆ˜ê°€ ìˆìœ¼ë©´ ê·¸ ì¤‘ì—ì„œ ì„ íƒ
            const movesToConsider = defenseMoves.length > 0 ? defenseMoves : validMoves;
            
            // 3. ì ìˆ˜ í‰ê°€ (ë” ì •êµí•˜ê²Œ)
            const scored = movesToConsider.map(move => {
                let score = 0;
                const [row, col] = move;
                
                // ì£¼ë³€ í‰ê°€
                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                let emptyCount = 0;
                let myCount = 0;
                let enemyCount = 0;
                
                for (const [dr, dc] of directions) {
                    const nr = row + dr;
                    const nc = col + dc;
                    if (this.isValidCell(nr, nc)) {
                        if (this.board[nr][nc] === null) emptyCount++;
                        else if (this.board[nr][nc] === 'orange') myCount++;
                        else if (this.board[nr][nc] === 'blue') enemyCount++;
                    }
                }
                
                // ì˜í†  í™•ì¥ ê°€ëŠ¥ì„±
                score += emptyCount * 3;
                // ì—°ê²°ì„±
                score += myCount * 2;
                // ìƒëŒ€ ê²¬ì œ
                score += enemyCount * 4;
                
                // ì¤‘ì•™ ì„ í˜¸ (ì´ˆë°˜)
                if (this.moveHistory.length < 20) {
                    const centerDist = Math.abs(row - 4) + Math.abs(col - 4);
                    score += (8 - centerDist) * 1.5;
                }
                
                return { move, score };
            });

            scored.sort((a, b) => b.score - a.score);
            const topMoves = scored.slice(0, Math.max(1, Math.floor(scored.length * 0.2)));
            return topMoves[Math.floor(Math.random() * topMoves.length)].move;
        };

        // ì–´ë ¤ì›€ AI: 4ìˆ˜ ì•ì„ ë´„ + ê³ ê¸‰ ì „ëµ
        game.aiMoveHard = function(validMoves) {
            // 1. ì¦‰ì‹œ ìŠ¹ë¦¬ ìˆ˜
            for (const move of validMoves) {
                const [row, col] = move;
                this.board[row][col] = 'orange';
                const captured = this.checkCapture(row, col);
                this.board[row][col] = null;
                
                if (captured.length > 0) {
                    return move;
                }
            }
            
            // 2. ì •êµí•œ ë°©ì–´ (2ìˆ˜ ì•ê¹Œì§€)
            const safeMoves = validMoves.filter(move => {
                const [row, col] = move;
                this.board[row][col] = 'orange';
                
                let isSafe = true;
                // ìƒëŒ€ì˜ ëª¨ë“  ê°€ëŠ¥í•œ ì‘ìˆ˜ í™•ì¸
                for (let r = 0; r < 9; r++) {
                    for (let c = 0; c < 9; c++) {
                        if (this.board[r][c] === null) {
                            this.board[r][c] = 'blue';
                            const captured = this.checkCapture(r, c);
                            this.board[r][c] = null;
                            
                            if (captured.some(([cr, cc]) => cr === row && cc === col)) {
                                isSafe = false;
                                break;
                            }
                        }
                    }
                    if (!isSafe) break;
                }
                
                this.board[row][col] = null;
                return isSafe;
            });
            
            const movesToConsider = safeMoves.length > 0 ? safeMoves : validMoves;
            
            // 3. ê³ ê¸‰ ì ìˆ˜ í‰ê°€
            const scored = movesToConsider.map(move => {
                let score = 0;
                const [row, col] = move;
                
                // ì‹œë®¬ë ˆì´ì…˜: ì´ ìˆ˜ë¥¼ ë‘ì—ˆì„ ë•Œì˜ ë³´ë“œ í‰ê°€
                this.board[row][col] = 'orange';
                
                // ì˜í–¥ë ¥ ê³„ì‚° (2ì¹¸ ë²”ìœ„)
                for (let dr = -2; dr <= 2; dr++) {
                    for (let dc = -2; dc <= 2; dc++) {
                        const nr = row + dr;
                        const nc = col + dc;
                        if (this.isValidCell(nr, nc) && this.board[nr][nc] === null) {
                            const dist = Math.abs(dr) + Math.abs(dc);
                            score += (5 - dist); // ê±°ë¦¬ì— ë”°ë¼ ì ìˆ˜
                        }
                    }
                }
                
                // ì—°ê²°ì„± í‰ê°€
                const directions = [[-1,0], [1,0], [0,-1], [0,1]];
                for (const [dr, dc] of directions) {
                    const nr = row + dr;
                    const nc = col + dc;
                    if (this.isValidCell(nr, nc)) {
                        if (this.board[nr][nc] === 'orange') {
                            score += 5; // ë‚´ ë§ê³¼ ì—°ê²°
                        } else if (this.board[nr][nc] === 'blue') {
                            score += 7; // ìƒëŒ€ ê·¼ì²˜ (ê²¬ì œ)
                        }
                    }
                }
                
                // ìƒëŒ€ í¬ìœ„ ê°€ëŠ¥ì„±
                let nearbyEnemies = 0;
                for (const [dr, dc] of directions) {
                    const nr = row + dr;
                    const nc = col + dc;
                    if (this.isValidCell(nr, nc) && this.board[nr][nc] === 'blue') {
                        nearbyEnemies++;
                    }
                }
                if (nearbyEnemies >= 2) {
                    score += 10; // ìƒëŒ€ë¥¼ ë‘˜ëŸ¬ì‹¸ê¸° ì‹œì‘
                }
                
                // ì¤‘ì•™ ì œì–´ (ì´ˆë°˜ë§Œ)
                if (this.moveHistory.length < 15) {
                    const centerDist = Math.abs(row - 4) + Math.abs(col - 4);
                    score += (8 - centerDist) * 2;
                }
                
                this.board[row][col] = null;
                
                return { move, score };
            });

            scored.sort((a, b) => b.score - a.score);
            // ìƒìœ„ 10%ë§Œ ê³ ë ¤
            const topMoves = scored.slice(0, Math.max(1, Math.floor(scored.length * 0.1)));
            return topMoves[0].move; // ìµœì„ ì˜ ìˆ˜ë§Œ ì„ íƒ
        };

        // ì´ˆê¸° ë‚œì´ë„ ì„¤ì •
        game.setDifficulty('medium');
    </script>
</body>
</html>
